//@version=6
strategy('Spot ATR Strategy', 
     overlay=true,
     commission_type=strategy.commission.percent,
     commission_value=0.1,
     slippage=1,
     initial_capital=10000)

import alexborda/AlexLib/1 as lib

// *** Inputs de Estrategia ***
// Grupos
string G_STRAT              = "1. Filtros de Estrategia"
string G_ENTRYEXIT          = "1.1 Lógica Entrada/Salida"
string G_ADX                = "1.2 Filtro ADX"
string G_VOL                = "1.3 Filtro Volumen"
string G_ATR                = "2. Configuración ATR"
string G_SIZE               = "3. Tamaño de Posición"
string G_MGMT               = "4. Gestión Trade & TSL"
string G_ORD                = "5. Configuración de Órdenes"
string G_VIS                = "6. Visuales y Depuración"
string G_RISK               = "7. Control de Riesgo Adicional" 
string G_LINREG             = "8. Configuración Regresión Lineal"
string TSL_METHOD_ATR_PRICE = "ATR (desde Precio)"
string TSL_METHOD_ATR_LOWEST= "ATR (desde Mínimo Reciente)"
string TSL_METHOD_PERCENT   = "Porcentaje (desde Cierre)"

// Inputs Filtros de Estrategia
emaLen              = input.int(15, title="EMA Corta Longitud", group=G_STRAT, minval=1, tooltip="Período de la Media Móvil Exponencial (EMA) rápida, usada para lógica de salida y como referencia de corto plazo.")
htf         = input.timeframe("D", title="EMA Larga TF", group=G_STRAT, tooltip="Temporalidad de la EMA lenta (largo plazo) para filtrar tendencia general (ej. 'D'=Diario, '240'=4 Horas). La entrada solo ocurre si el precio está sobre esta EMA.")
entryLookback          = input.int(7, title="Entrada Lookback Mínimo", group=G_ENTRYEXIT, minval=2, tooltip="Número de barras hacia atrás para buscar el mínimo más bajo (`low`) como parte de la señal de entrada trigger.")
entryWaitBars         = input.int(3, title="Número de barras a esperar", group=G_ENTRYEXIT, minval=0, tooltip="Número de barras a esperar después de la señal 'Trigger' antes de buscar la vela de reversión (`close > open`) para ejecutar la compra.")
entryExpiryBars       = input.int(10, title="Entrada Expiración (barras)", group=G_ENTRYEXIT, minval=0, tooltip="Número máximo de barras a esperar después del trigger. Si se supera este límite, la señal expira y se reinicia.") // NUEVO: Expiración de señal
exitLookback           = input.int(7, title="Salida Lookback Máximo", group=G_ENTRYEXIT, minval=2, tooltip="Número de barras hacia atrás para buscar el cierre más alto (`close`) para la condición de Salida Peak.")
exitEmaBars           = input.int(5, title="Salida Mín Barras s/EMA", group=G_ENTRYEXIT, minval=2, tooltip="Número mínimo de barras consecutivas que el precio debe cerrar sobre la EMA corta para activar la Salida Peak.")
adxLen                 = input.int(14, title='ADX Longitud', group=G_ADX, minval=1, tooltip="Número de períodos para el cálculo del Average Directional Index (ADX).")
adxSmooth              = input.int(14, title='ADX Suavizado', group=G_ADX, minval=1, tooltip="Número de períodos para el suavizado interno del ADX (usualmente igual a la Longitud ADX).")
adxThresholdBase      = input.float(15.0, title='ADX Umbral Base', group=G_ADX, minval=0, tooltip="Nivel mínimo base que debe superar el ADX para considerar la entrada (se ajusta dinámicamente con la volatilidad ATR).")
useAdxFilter          = input.bool(true, title="Usar Filtro ADX", group=G_ADX, tooltip="Activar/desactivar el filtro ADX para las entradas.") // NUEVO: Opción para activar/desactivar ADX
volLen                 = input.int(20, title="Volumen Longitud MA", group=G_VOL, minval=1, tooltip="Número de períodos para la Media Móvil Exponencial (EMA) del volumen.")
volFactor              = input.float(1.1, title="Volumen Factor Mínimo", group=G_VOL, minval=0, tooltip="Factor multiplicador de la EMA de volumen. El volumen actual debe superar (EMA Volumen * Factor) para considerar la entrada.", step=0.1)
useVolFilter          = input.bool(true, title="Usar Filtro Volumen", group=G_VOL, tooltip="Activar/desactivar el filtro de volumen para las entradas.") // NUEVO: Opción para activar/desactivar volumen
atrLen                 = input.int(14, title='ATR Longitud', group=G_ATR, minval=1, tooltip="Número de períodos para el cálculo del Average True Range (ATR).")
atrMultSL                = input.float(1.2, title='ATR Mult SL Inicial', group=G_ATR, minval=0.1, tooltip="Multiplicador del ATR para calcular la distancia del Stop Loss inicial desde el precio estimado de entrada.", step=0.1)
minSLPct          = input.float(0.5, title='SL Mínimo %', group=G_ATR, minval=0.01, maxval=10, tooltip="Distancia mínima del Stop Loss como porcentaje del precio de entrada.", step=0.01) // NUEVO: SL mínimo configurable
equityPct            = input.float(0.99, title='Capital % a Usar x Trade', group=G_SIZE, minval=0.01, maxval=1, tooltip="Porcentaje del capital total a usar en cada operación.", step=0.01)
minQty                 = input.float(0.00011, title='Activo Cantidad Mínima', group=G_SIZE, step=0.0001, minval=0.00011, tooltip="Cantidad mínima del activo base (ej. BTC) permitida por el exchange para colocar una orden.")
tslMethod        = input.string(TSL_METHOD_PERCENT, "TSL Método", options=[TSL_METHOD_ATR_PRICE, TSL_METHOD_ATR_LOWEST, TSL_METHOD_PERCENT], group=G_MGMT, tooltip="Elige el método de cálculo del Trailing Stop Loss (TSL). Las opciones explican cómo se calcula.")
tslSource              = input.string("low", "TSL Fuente [ATR Precio]", options=["close", "low"], group=G_MGMT, tooltip="Precio base (Close o Low) para el cálculo del TSL cuando el método es 'ATR (desde Precio)'.")
tslMult                = input.float(1.9, title='TSL Mult ATR', group=G_MGMT, minval=0.1, tooltip="Multiplicador del ATR usado para calcular la distancia del TSL en los métodos basados en ATR.", step=0.1)
tslLookback            = input.int(10, "TSL Lookback Mínimo", group=G_MGMT, minval=2, tooltip="Número de barras hacia atrás para buscar el mínimo (`low`) usado en el método TSL 'ATR (desde Mínimo Reciente)'.")
tslPct             = input.float(0.5, "TSL Porcentaje", group=G_MGMT, minval=0.01, maxval=1, tooltip="Distancia porcentual fija desde el cierre (`close`) usada para el TSL en el método 'Porcentaje'.", step=0.01)
beMult                 = input.float(1.0, title='BE Multiplicador ATR', group=G_MGMT, minval=0.1, tooltip="Multiplicador del ATR desde la entrada. El precio debe superar (Entrada + ATR * Mult) para mover el SL a Break-Even.", step=0.1)
tpMult                 = input.float(1.7, title='TP Multiplicador ATR', group=G_MGMT, minval=0.1, tooltip="Multiplicador del ATR desde la entrada para calcular el nivel de Take Profit.", step=0.1)
exitMult                 = input.float(1.0, title='Exit Multiplicador', group=G_MGMT, minval=0.1, tooltip="Multiplicador añade un margen de tolerancia al precio para que no necesite tocar exactamente el mínimo anterior, sino que puede estar ligeramente por encima hasta un % más alto.", step=0.1)
requireVolConfirmExit     = input.bool(true, title="Requerir Volumen para Salida Peak", group=G_MGMT, tooltip="Requiere que el volumen sea mayor que el promedio para activar la salida Peak.") // NUEVO: Confirmación de volumen para salida
maxDrawdownPct        = input.float(10, title="Máx Drawdown %", group=G_RISK, minval=1, maxval=100, tooltip="Máximo drawdown permitido como porcentaje del capital antes de detener operaciones.", step=0.1) // NUEVO: Control de drawdown
lrEntryLen        = input.int(10, title="LR Entrada Longitud", group=G_LINREG, minval=2, tooltip="Número de barras para la Regresión Lineal usada en la condición de entrada.")
lrTslLen          = input.int(15, title="LR TSL Longitud", group=G_LINREG, minval=2, tooltip="Número de barras para la Regresión Lineal usada en el Trailing Stop.")
lrTrendLen        = input.int(20, title="LR Tendencia Longitud", group=G_LINREG, minval=2, tooltip="Número de barras para la Regresión Lineal usada como filtro de tendencia.")
useLrTrendFilter = input.bool(false, title="Usar Filtro Tendencia LR", group=G_LINREG, tooltip="Activar/desactivar el filtro de tendencia basado en la Regresión Lineal.")
order_type              = input.string("limit", title="Tipo Orden Entrada", options=["limit", "market"], group=G_ORD, tooltip="Tipo de orden a usar para las entradas (Market recomendado con entrada diferida).") 
priceOffsetPips       = input.int(5, title='Límite Offset Pips', group=G_ORD, minval=0, tooltip="Para órdenes Límite: Número de pips/ticks por debajo del precio actual para colocar la orden. 0 usa el precio de cierre.")
enableWebhookAlerts   = input.bool(false, title="Enable Webhook Alerts?", group=G_ORD, tooltip="Enable sending alerts for trade execution via webhooks.")
webhookUrl             = input.string("", title="Webhook URL", group=G_ORD, tooltip="The URL to send webhook alerts to.")

// *** Variables Globales de Estado ***
var float   calcQty    = na
var float   finalQty         = na
var float   entry_price       = na
var float   sl_price          = na
var float   tp_price          = na
var bool    be_active         = false
var bool    trl_active        = false
var bool    entrySignalActive = false
var int     barsSinceSignal   = 0
var float   lowestSinceSignal = na
var float   peakEquity       = strategy.initial_capital
var float   drawdownAmount   = 0.0
var bool    riskLimitReached= false
var int     consecutiveLosses= 0

// *** Cálculos de Indicadores ***
// EMAs - Optimizado para calcular una sola vez
ema_value         = ta.ema(close, emaLen)
float htfEmaValue = request.security(syminfo.tickerid, htf, ema_value[1], lookahead=barmerge.lookahead_off)
bool isBullish    = close > htfEmaValue

// ATR Robusto - Optimizado
float tr = ta.tr
float atrFromTa = ta.atr(atrLen)
float smaOfTr = ta.sma(tr, atrLen)
float atrValue = atrFromTa
if na(atrValue) or atrValue <= 0
    atrValue := smaOfTr
if na(atrValue) or atrValue <= 0
    atrValue := close * 0.02

// Distancia SL Inicial - Con mínimo configurable
initialSLDist = atrValue * atrMultSL
initialSLDist := math.max(initialSLDist, close * (minSLPct/100))

// ADX - Optimizado para calcular una sola vez
[di_plus, di_minus, adx] = ta.dmi(adxLen, adxSmooth)
float volatilityFactor = close > 0 ? atrValue / close : 0
float adxThreshold = adxThresholdBase * (1 + volatilityFactor)
bool adx_filter = not useAdxFilter or (adx > adxThreshold) // MEJORADO: usa flag para activar/desactivar

// Volumen Relativo - Optimizado
float volAvg = ta.ema(volume, volLen)
float volRelative = volAvg > 0 ? volume / volAvg : 0
bool vol_filter = not useVolFilter or (volume > 0 and volRelative > volFactor) // MEJORADO: usa flag para activar/desactivar

// Condiciones Específicas Entrada/Salida - Optimizado para calcular valores una sola vez
float lowestLowCurrent = ta.lowest(low, entryLookback) * exitMult
float lowestLowPrior = ta.lowest(low[1], entryLookback)
bool isLowestLowOrPrior = low == lowestLowCurrent or low[1] == lowestLowPrior
bool isBelowEma = close < ema_value

// Cálculos de Regresión Lineal (NUEVO)
float lrLowValue = ta.linreg(low, lrEntryLen, 0)
float lrTslValue = ta.linreg(low, lrTslLen, 0) // Usar low para TSL basado en mínimos
float lrCloseTrendValue = ta.linreg(close, lrTrendLen, 0)
// Cálculo de la pendiente (derivada) de la Regresión Lineal manualmente
float lrTrendSlope = lrCloseTrendValue - lrCloseTrendValue[1]

// Para salida peak - Optimizado
float highestExitClose = ta.highest(close, exitLookback)
bool isHighestClose = close == highestExitClose
int barsAboveEma = ta.barssince(close <= ema_value)
bool stayedAboveEma = barsAboveEma >= exitEmaBars
bool volConfirmExit = not requireVolConfirmExit or volRelative > 1.0
bool exitPeakCondition = isHighestClose and stayedAboveEma and volConfirmExit // MEJORADO: añadida confirmación de volumen

// *** Control de Riesgo Adicional *** (NUEVO)
// Resetear contadores diarios al inicio de un nuevo día

// Actualizar pico de capital y calcular Drawdown
peakEquity := math.max(peakEquity, strategy.equity)
drawdownAmount := strategy.equity - peakEquity

// Verificar límites de riesgo

float drawdownPct = peakEquity > 0 ? drawdownAmount / peakEquity * 100 : 0.0
riskLimitReached := drawdownPct <= -maxDrawdownPct

// *** Gestión de Riesgo y Tamaño de Posición ***
equity = strategy.equity
maxEquityRisk = equity * equityPct

// Cálculo de Cantidad - Optimizado
calcQty := close > 0 ? maxEquityRisk / close : 0.0

// Ajustes y Redondeo Final
float qtyAfterMin = na(calcQty) ? na : math.min(calcQty, maxEquityRisk / close)
float qtyAfterMax = na(qtyAfterMin) ? na : math.max(minQty, qtyAfterMin)
finalQty := na(qtyAfterMax) ? na : lib.round(qtyAfterMax, 6)

// *** GESTIÓN DE TRADE (SL/TP/TSL) *** - Refactorizado
// Función para calcular SL/TP/BE/TSL (NUEVO: Funciones para reducir redundancia)
calcTakeProfit(entry, atr) =>
    if not na(entry) and entry > 0 and not na(atr) and atr > 0
        float tp_atr_distance = atr * tpMult
        tp_atr_distance := math.max(tp_atr_distance, entry * 0.01)
        lib.round(entry + tp_atr_distance, 5)
    else
        na

calcBreakEvenLevel(entry, atr) =>
    if not na(entry) and entry > 0 and not na(atr) and atr > 0
        float be_atr_distance = atr * beMult
        be_atr_distance := math.max(be_atr_distance, entry * 0.005)
        lib.round(entry + be_atr_distance, 5)
    else
        na

calcTrailingStop(currentPrice, atr, lowestPrice) =>
    if not na(currentPrice) and currentPrice > 0 and not na(atr) and atr > 0
        float tsl_atr_distance = atr * tslMult
        tsl_atr_distance := math.max(tsl_atr_distance, currentPrice * 0.005)
        
        if tslMethod == TSL_METHOD_ATR_PRICE
            float base_price = tslSource == "close" ? close : low
            lib.round(base_price - tsl_atr_distance, 5)
        else if tslMethod == TSL_METHOD_ATR_LOWEST
            // Usar Regresión Lineal para TSL basado en mínimos
            lib.round(lrTslValue - tsl_atr_distance, 5)
        else // TSL_METHOD_PERCENT
            lib.round(currentPrice * (1 - tslPct), 5)
    else
        na

float be_price = na
float potential_new_stop = na
bool be_activated_this_bar = false
bool tsl_updated_this_bar = false
float lowest_low_for_tsl = ta.lowest(low, tslLookback)

if strategy.position_size > 0
    entry_price := strategy.position_avg_price
    
    // Calcular TP y BE
    tp_price := calcTakeProfit(entry_price, atrValue)
    be_price := calcBreakEvenLevel(entry_price, atrValue)
    
    // Calcular Nivel Potencial TSL
    potential_new_stop := calcTrailingStop(close, atrValue, lowest_low_for_tsl)
    
    // Resetear flags
    be_activated_this_bar := false
    tsl_updated_this_bar := false
    
    // Actualización SL (BE / TSL)
    if not na(be_price) and beMult > 0 and not be_active and close > be_price
        be_active := true
        trl_active := true
        if not na(entry_price)
            float new_sl = lib.round(entry_price, 5)
            if na(sl_price) or new_sl != sl_price
                sl_price := new_sl
                be_activated_this_bar := true
    
    if trl_active and not na(potential_new_stop) and not na(sl_price)
        if potential_new_stop > sl_price
            sl_price := potential_new_stop
            tsl_updated_this_bar := true

// *** CONDICIONES DE ENTRADA ***
// Modificada para usar Regresión Lineal
bool linreg_entry_condition = low <= lrLowValue // El mínimo actual está en o por debajo de la línea de regresión
entryTriggerCondition = linreg_entry_condition and initialSLDist > 0 and adx_filter and vol_filter and isBelowEma

// *** LÓGICA DE ENTRADA DIFERIDA ***
if not entryTriggerCondition or (entrySignalActive and barsSinceSignal > entryExpiryBars)
    entrySignalActive := false
    barsSinceSignal := 0

// Activar búsqueda y rastrear mínimo cuando la señal trigger aparece
if entryTriggerCondition and not entrySignalActive and not riskLimitReached
    entrySignalActive := true
    barsSinceSignal := 0 // Resetear contador
    lowestSinceSignal := low // Empezar rastreo

// Si la señal está activa (modo búsqueda/espera)
if entrySignalActive
    barsSinceSignal := barsSinceSignal + 1 // Contar barras
    if na(lowestSinceSignal) or low < lowestSinceSignal // Actualizar mínimo
        lowestSinceSignal := low

// Condición FINAL de Compra (Ejecución)
bool reversalCandle = close > open
bool executeBuy = entrySignalActive and barsSinceSignal >= entryWaitBars and reversalCandle and not riskLimitReached

// Permiso para Operar (canTrade)
bool qty_is_valid = not na(finalQty) and finalQty >= minQty
bool cost_is_valid = not na(finalQty) and not na(close) and close > 0
float estimatedCost = cost_is_valid ? lib.round(finalQty * close, 5) : na
bool equityEnough = not na(estimatedCost) and equity > estimatedCost

// Filtro de Tendencia con Regresión Lineal (NUEVO)
bool lrTrendFilterActive = useLrTrendFilter and lrTrendSlope > 0 // Activo si se usa el filtro y la pendiente es positiva

canTrade = strategy.position_size == 0 and qty_is_valid and equityEnough and not riskLimitReached and (not useLrTrendFilter or lrTrendFilterActive) // Añadido filtro de tendencia LR

// Ejecutar Entrada
if executeBuy and canTrade
    entry_price := na
    if order_type == 'limit'
        limitOffset = priceOffsetPips * syminfo.mintick
        entry_price := limitOffset == 0 ? close : close - limitOffset
        entry_price := lib.round(entry_price, 5)
    else // Market
        entry_price := na

    float initialSLPrice = na
    if not na(close) and not na(initialSLDist)
        float entryPriceEstimate = order_type == 'limit' ? entry_price : close
        if not na(entryPriceEstimate)
            initialSLPrice := entryPriceEstimate - initialSLDist
            initialSLPrice := lib.round(initialSLPrice, 5)

    if not na(initialSLPrice)
        strategy.entry("Compra", strategy.long, qty=finalQty, limit=entry_price)
        entrySignalActive := false // Resetear estado DESPUÉS de enviar orden

        if strategy.position_size[1] == 0 // Usar [1] para verificar si NO había posición antes de esta barra
            sl_price := initialSLPrice // Asignar SL inicial
            tp_price := na
            be_active := false
            trl_active := false

        // Añadir alerta de entrada - Refactorizado usando la función
        if enableWebhookAlerts
            string entryAlertMessage = '{ "symbol": "' + syminfo.tickerid + '", "side": "buy", "qty": ' + str.tostring(finalQty) + ', "type": "' + order_type + '"'
            if order_type == 'limit'
                entryAlertMessage += ', "price": ' + str.tostring(entry_price)
            entryAlertMessage += ' }'
            if enableWebhookAlerts and webhookUrl != ""
                alert(entryAlertMessage + "{{webhook=" + webhookUrl + "}}")

// *** CONDICIONES DE SALIDA ***
// Salida 1: Pendiente por SL/TP/BE/TSL vía strategy.exit
if strategy.position_size > 0 and not na(sl_price)
    float actual_limit_price = trl_active ? na : tp_price // TP Condicional
    strategy.exit(id='Venta SL/TP', from_entry='Compra', stop=sl_price, limit=actual_limit_price, comment_profit='TP', comment_loss='SL/BE/TSL')

    // Añadir alerta para salida SL/TP/BE/TSL - Refactorizado
    if enableWebhookAlerts
        string exitAlertMessage = '{ "symbol": "' + syminfo.tickerid + '", "side": "sell", "qty": ' + str.tostring(strategy.position_size) + ', "type": "market", "reason": "SL/TP/BE/TSL" }'
        if enableWebhookAlerts and webhookUrl != ""
            alert(exitAlertMessage + "{{webhook=" + webhookUrl + "}}")

// Salida 2: Inmediata por Condición "Peak Exit" vía strategy.close
if strategy.position_size > 0 and exitPeakCondition and not trl_active
    strategy.close(id='Compra', comment='Peak Exit')

    // Añadir alerta para Peak Exit - Refactorizado
    if enableWebhookAlerts
        string peak_exitAlertMessage = '{ "symbol": "' + syminfo.tickerid + '", "side": "sell", "qty": ' + str.tostring(strategy.position_size) + ', "type": "market", "reason": "Peak Exit" }'
        if enableWebhookAlerts and webhookUrl != ""
            alert(peak_exitAlertMessage + "{{webhook=" + webhookUrl + "}}")

// EMA Plots
plot(ema_value, title="EMA Corta", color=color.new(color.yellow, 0), linewidth=1)
plot(htfEmaValue, title="EMA HTF (Non-Repaint)", color=color.new(color.aqua, 0), linewidth=1)

// Indicadores de estado (NUEVO)
bgcolor(riskLimitReached ? color.new(color.red, 90) : na, title="Límite de Riesgo Alcanzado")