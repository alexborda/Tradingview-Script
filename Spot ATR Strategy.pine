//@version=6
strategy('Spot ATR Strategy', // Nombre actualizado
     overlay=true,
     commission_type=strategy.commission.percent,
     commission_value=0.1,
     slippage=1,
     initial_capital=10000)

// --- Importar librería Personal (ASEGÚRATE QUE LOS DATOS SEAN CORRECTOS) ---
import alexborda/AlexLib/1 as lib

// *** Inputs de Estrategia ***
// Grupos
string G_STRAT = "1. Filtros de Estrategia"
string G_ENTRYEXIT = "1.1 Lógica Entrada/Salida"
string G_ADX = "1.2 Filtro ADX"
string G_VOL = "1.3 Filtro Volumen"
string G_ATR = "2. Configuración ATR"
string G_SIZE = "3. Tamaño de Posición"
string G_MGMT = "4. Gestión Trade & TSL" // Grupo renombrado
string G_ORD = "5. Configuración de Órdenes"
string G_VIS = "6. Visuales y Depuración"

// Inputs Filtros de Estrategia
ema_length         = input.int(10, title="EMA Corta Longitud", group=G_STRAT, minval=1, tooltip="Período de la Media Móvil Exponencial (EMA) rápida, usada para lógica de salida y como referencia de corto plazo.")
HigherTimeframe    = input.timeframe("D", title="EMA Larga TF", group=G_STRAT, tooltip="Temporalidad de la EMA lenta (largo plazo) para filtrar tendencia general (ej. 'D'=Diario, '240'=4 Horas). La entrada solo ocurre si el precio está sobre esta EMA.")

// Inputs Lógica Entrada/Salida
entry_lookback     = input.int(7, title="Entrada Lookback Mínimo", group=G_ENTRYEXIT, minval=2, tooltip="Número de barras hacia atrás para buscar el mínimo más bajo (`low`) como parte de la señal de entrada trigger.")
entry_wait_bars    = input.int(3, title="Número de barras a esperar", group=G_ENTRYEXIT, minval=0, tooltip="Número de barras a esperar después de la señal 'Trigger' antes de buscar la vela de reversión (`close > open`) para ejecutar la compra.")

exit_lookback      = input.int(7, title="Salida Lookback Máximo", group=G_ENTRYEXIT, minval=2, tooltip="Número de barras hacia atrás para buscar el cierre más alto (`close`) para la condición de Salida Peak.")
exit_ema_bars      = input.int(5, title="Salida Mín Barras s/EMA", group=G_ENTRYEXIT, minval=2, tooltip="Número mínimo de barras consecutivas que el precio debe cerrar sobre la EMA corta para activar la Salida Peak.")

// Inputs ADX
adx_len            = input.int(14, title='ADX Longitud', group=G_ADX, minval=1, tooltip="Número de períodos para el cálculo del Average Directional Index (ADX).")
adx_smooth         = input.int(14, title='ADX Suavizado', group=G_ADX, minval=1, tooltip="Número de períodos para el suavizado interno del ADX (usualmente igual a la Longitud ADX).")
adx_threshold_base = input.float(15.0, title='ADX Umbral Base', group=G_ADX, minval=0, tooltip="Nivel mínimo base que debe superar el ADX para considerar la entrada (se ajusta dinámicamente con la volatilidad ATR).")

// Inputs Volumen
vol_len            = input.int(20, title="Volumen Longitud MA", group=G_VOL, minval=1, tooltip="Número de períodos para la Media Móvil Exponencial (EMA) del volumen.")
vol_factor         = input.float(1.1, title="Volumen Factor Mínimo", group=G_VOL, minval=0, tooltip="Factor multiplicador de la EMA de volumen. El volumen actual debe superar (EMA Volumen * Factor) para considerar la entrada.", step=0.1)

// Inputs ATR
atr_len            = input.int(14, title='ATR Longitud', group=G_ATR, minval=1, tooltip="Número de períodos para el cálculo del Average True Range (ATR).")
atr_mult           = input.float(1.2, title='ATR Mult SL Inicial', group=G_ATR, minval=0.1, tooltip="Multiplicador del ATR para calcular la distancia del Stop Loss inicial desde el precio estimado de entrada.", step=0.1)

// Inputs Tamaño de Posición
eqty_type          = input.string(defval="Porcentaje", title="Tipo Tamaño", options=["Porcentaje","ATR"], group=G_SIZE, tooltip="Método para calcular el tamaño de la posición: 'Porcentaje' (usa % Máx Equity) o 'ATR' (usa % Riesgo y distancia SL).")
eqty_percent       = input.float(99, title='Capital % Máx x Trade', group=G_SIZE, minval=1, maxval=100, tooltip="Máximo porcentaje del capital total permitido para usar en una sola operación.") / 100
risk_percent       = input.float(100, title='ATR % Riesgo x Trade', group=G_SIZE, minval=0.1, maxval=100, tooltip="Porcentaje del capital total a arriesgar en una operación, usado solo si 'Tipo Tamaño' es 'ATR'.") / 100
min_qty            = input.float(0.00011, title='Activo Cantidad Mínima', group=G_SIZE, step=0.0001, minval=0.00011, tooltip="Cantidad mínima del activo base (ej. BTC) permitida por el exchange para colocar una orden.")

// Inputs Gestión Trade & TSL
string TSL_METHOD_ATR_PRICE = "ATR (desde Precio)"
string TSL_METHOD_ATR_LOWEST = "ATR (desde Mínimo Reciente)"
string TSL_METHOD_PERCENT = "Porcentaje (desde Cierre)"
tsl_method_input = input.string(TSL_METHOD_PERCENT, "TSL Método", options=[TSL_METHOD_ATR_PRICE, TSL_METHOD_ATR_LOWEST, TSL_METHOD_PERCENT], group=G_MGMT, tooltip="Elige el método de cálculo del Trailing Stop Loss (TSL). Las opciones explican cómo se calcula.")
tsl_source       = input.string("low", "TSL Fuente [ATR Precio]", options=["close", "low"], group=G_MGMT, tooltip="Precio base (Close o Low) para el cálculo del TSL cuando el método es 'ATR (desde Precio)'.")
trl_mult         = input.float(1.9, title='TSL Mult ATR', group=G_MGMT, minval=0.1, tooltip="Multiplicador del ATR usado para calcular la distancia del TSL en los métodos basados en ATR.", step=0.1)
tsl_lookback     = input.int(10, "TSL Lookback Mínimo", group=G_MGMT, minval=2, tooltip="Número de barras hacia atrás para buscar el mínimo (`low`) usado en el método TSL 'ATR (desde Mínimo Reciente)'.")
tsl_percent      = input.float(5.0, "TSL Porcentaje", group=G_MGMT, minval=0.1, tooltip="Distancia porcentual fija desde el cierre (`close`) usada para el TSL en el método 'Porcentaje'.") / 100.0
be_mult          = input.float(1.0, title='BE Multiplicador ATR', group=G_MGMT, minval=0.1, tooltip="Multiplicador del ATR desde la entrada. El precio debe superar (Entrada + ATR * Mult) para mover el SL a Break-Even.", step=0.1)
tp_mult          = input.float(1.7, title='TP Multiplicador ATR', group=G_MGMT, minval=0.1, tooltip="Multiplicador del ATR desde la entrada para calcular el nivel de Take Profit.", step=0.1)
ex_mult          = input.float(1.0, title='Exit Multiplicador', group=G_MGMT, minval=0.1, tooltip="Multiplicador añade un margen de tolerancia al precio para que no necesite tocar exactamente el mínimo anterior, sino que puede estar ligeramente por encima hasta un % más alto.", step=0.1)

// Inputs Configuración de Órdenes
order_type         = input.string("limit", title="Tipo Orden Entrada", options=["limit", "market"], group=G_ORD, tooltip="Tipo de orden a usar para las entradas (Market recomendado con entrada diferida).") // Default Market
price_offset_pips  = input.int(5, title='Límite Offset Pips', group=G_ORD, minval=0, tooltip="Para órdenes Límite: Número de pips/ticks por debajo del precio actual para colocar la orden. 0 usa el precio de cierre.")

// New Inputs for Webhook Alerts
enable_webhook_alerts = input.bool(false, title="Enable Webhook Alerts?", group=G_ORD, tooltip="Enable sending alerts for trade execution via webhooks.")
webhook_url = input.string("", title="Webhook URL", group=G_ORD, tooltip="The URL to send webhook alerts to.")

// Inputs Visuales y Depuración
show_debug_plots   = input.bool(false, title="Ver Plots Debug?", group=G_VIS, tooltip="Activa/Desactiva la visualización de plots técnicos adicionales para depuración.")
show_debug_labels  = input.bool(true, title="Ver Labels Debug?", group=G_VIS, tooltip="Activa/Desactiva la visualización de etiquetas con información detallada del estado y cálculos.")
bgcolor_active     = input.bool(true, title="Resaltar Fondo Ejecución?", group=G_VIS, tooltip="Activa/Desactiva el resaltado de fondo en las barras donde se ejecuta una entrada.")
// *** Variables Globales de Estado ***
var float   calculated_qty        = na
var float   final_qty             = na
var float   long_entry_price      = na
var float   long_sl_price         = na
var float   long_tp_price         = na
var bool    long_be_active        = false
var bool    long_trl_active       = false
var bool    entrySignalActive     = false
var int     barsSinceSignal       = 0
var float   lowestSinceSignal     = na

// *** Cálculos de Indicadores ***
// EMAs
ema_value         = ta.ema(close, ema_length)
float htfEmaValue = request.security(syminfo.tickerid, HigherTimeframe, ema_value[1], lookahead=barmerge.lookahead_off)
bool isBullish    = close > htfEmaValue

// ATR - Optimizado
float trueRange    = ta.tr
float atrFromLib   = ta.atr(atrLen)
float smaOfTR      = ta.sma(trueRange, atrLen)
float atrCurrent   = na(atrFromLib) or atrFromLib <= 0 ? (na(smaOfTR) or smaOfTR <= 0 ? close * 0.01 : smaOfTR) : atrFromLib

// Distancia SL con mínimo configurable
float slDist = math.max(atrCurrent * atrMultSL, close * (minSLPct / 100.0))

bool adxPass = lib.validateADX(adxLen, atrCurrent, adxSmooth, adxThresholdBase, useAdxFilter)
bool volPass = lib.validateVolume(volume, volLen, volFactor, useVolFilter)
bool lrPass = true
float lrSlopeValue = 0.0
if useLrTrendFilter
    [tempLrPass, tempLrSlope] = lib.validateLR(close, lrTrendLen, true)
    lrPass := tempLrPass
    lrSlopeValue := tempLrSlope
else
    lrPass := true
    lrSlopeValue := 0.0

float lrTslVal     = ta.linreg(low, lrTslLen, 0)

int barsBelowShortEma = ta.barssince(close > currentEma)
bool crossoverShortEma = ta.crossover(close, currentEma)

float highestCloseVal = ta.highest(close, exitLookback)
bool isHighestCloseCond = close == highestCloseVal
int barsAboveShortEma = ta.barssince(close <= currentEma)
bool stayedAboveShortEma = barsAboveShortEma >= exitEmaBars
bool volumeConfirmsPeak = not volConfirmExit or (useVolFilter and volPass)
bool peakExitCond = isHighestCloseCond and stayedAboveShortEma and volumeConfirmsPeak

// Actualizar equity peak y calcular drawdown
if strategy.equity > peakEquity // Solo actualizar si el equity actual es mayor
    peakEquity := strategy.equity
float currentDrawdown = peakEquity - strategy.equity
float drawdownPct = peakEquity > 0 ? (strategy.equity - peakEquity) / peakEquity * 100 : 0.0
if drawdownPct >= maxDrawdownPct and not riskLimitReached // Si el drawdown supera el límite Y no se había alcanzado antes
    riskLimitReached := true
    alert("Límite de Drawdown Máximo (" + str.tostring(maxDrawdownPct) + "%) Alcanzado. Deteniendo nuevas operaciones.", alert.freq_once_per_bar) // Alerta una vez
if riskLimitReached and drawdownPct < (maxDrawdownPct * 0.5) // Ejemplo: recupera la mitad del drawdown
    riskLimitReached := false
    alert("Límite de Drawdown Reseteado. Operaciones reanudadas.", alert.freq_once_per_bar)

// *** Gestión de Posición ***
equity = strategy.equity
maxEquityToRisk = equity * equityPct // % del equity a usar

// Cálculo de Cantidad
calculated_qty := 0.0
if close > 0
    if eqty_type == 'Porcentaje' // Corregido
        calculated_qty := max_equity_risk / close
    else if eqty_type == 'ATR'
        if initial_sl_dista > 0
            calculated_qty := risk_per_trade / initial_sl_dista
        else
            calculated_qty := max_equity_risk / close
    else
        calculated_qty := min_qty
else
    calculated_qty := 0.0

// Ajustes y Redondeo Final
float qty_after_min = na(calculated_qty) ? na : math.min(calculated_qty, max_equity_risk / close)
float qty_after_max = na(qty_after_min) ? na : math.max(min_qty, qty_after_min)
final_qty           := na(qty_after_max) ? na : lib.round (qty_after_max,6) // Usar mintick

if show_debug_labels
    dbg_calc_qty_raw    := calculated_qty
    dbg_max_qty_allowed := max_equity_risk / close
    dbg_qty_after_min   := qty_after_min
    dbg_qty_after_max   := qty_after_max

// *** GESTIÓN DE TRADE (SL/TP/BE/TSL) ***
float long_be_price      = na
float potential_new_stop = na
bool be_activated_this_bar = false
bool tsl_updated_this_bar = false
float lowest_low_for_tsl = ta.lowest(low, tsl_lookback)

if strategy.position_size > 0
    EntryPrice := strategy.position_avg_price
    
    takeProfitPrice := lib.calcTP(EntryPrice, atrCurrent, tpMult, 2, 5)
    breakEvenActivationPrice := lib.calcBELevel(EntryPrice, atrCurrent, beMult, 2, 5)
    potentialNewStopLevel := lib.calcTSL(close, atrCurrent, tslMult, tslMethod, tslSource, lrTslVal, tslPct, lrSlopeValue, 2, 5)
    
    beActivatedThisBar := false
    tslUpdatedThisBar := false

    if not na(breakEvenActivationPrice) and beMult > 0 and not breakEvenActive and close > breakEvenActivationPrice
        breakEvenActive := true
        trailingActive := true
        if not na(EntryPrice)
            float newSlVal = lib.round(EntryPrice, 2, 5)
            if na(stopLossPrice) or newSlVal != stopLossPrice
                stopLossPrice := newSlVal
                beActivatedThisBar := true
    
    if trailingActive and not na(potentialNewStopLevel) and (na(stopLossPrice) or potentialNewStopLevel > stopLossPrice)
        stopLossPrice := potentialNewStopLevel
        tslUpdatedThisBar := true

// *** CONDICIONES DE ENTRADA ***
bool entryTrigger = (barsBelowShortEma >= retrBars and crossoverShortEma) and isBullish and slDist > 0 and adxPass and volPass and lrPass

// *** LÓGICA DE ENTRADA ***
bool qtyOk     = not na(finalPositionQty) and finalPositionQty >= minQty
bool costOk    = not na(finalPositionQty) and not na(close) and close > 0
float estCostVal  = costOk ? lib.round(finalPositionQty * close, 2, 5) : na
bool equityOk = not na(estCostVal) and equity > estCostVal
bool canEnterTrade = strategy.position_size == 0 and qtyOk and equityOk and not riskLimitReached

// *** EJECUTAR ENTRADA ***
if entryTrigger and canEnterTrade
    float entryPriceExec = na
    if orderType == 'limit'
        float limitOffsetVal = priceOffsetPips * syminfo.mintick
        entryPriceExec := lib.round((limitOffsetVal == 0 ? close : close - limitOffsetVal), 2, 5)

    float initialSl = na
    float slBasePrice = orderType == 'limit' ? (not na(entryPriceExec) ? entryPriceExec : close) : close
    if not na(slBasePrice) and not na(slDist)
        initialSl := lib.round(slBasePrice - slDist, 2, 5)

    if not na(initial_sl_price)
        strategy.entry("Compra", strategy.long, qty=final_qty, limit=entry_price)
        entrySignalActive := false // Resetear estado DESPUÉS de enviar orden

        if strategy.position_size[1] == 0 // Usar [1] para verificar si NO había posición antes de esta barra
            long_sl_price := initial_sl_price // Asignar SL inicial
            long_tp_price := na
            long_be_active := false
            long_trl_active := false

        // Add alert for entry
        if enable_webhook_alerts and webhook_url != ""
            string entry_alert_message = '{ "symbol": "' + syminfo.tickerid + '", "side": "buy", "qty": ' + str.tostring(final_qty) + ', "type": "' + order_type + '"'
            if order_type == 'limit'
                entry_alert_message += ', "price": ' + str.tostring(entry_price)
            entry_alert_message += ' }'
            alert(entry_alert_message, alert.freq_once_per_bar_close, webhook=webhook_url)

// *** CONDICIONES DE SALIDA ***
// Salida 1: Pendiente por SL/TP/BE/TSL vía strategy.exit
if strategy.position_size > 0 and not na(long_sl_price) and isBullish
    float actual_limit_price = long_trl_active ? na : long_tp_price// TP Condicional
    strategy.exit(id='Venta SL/TP', from_entry='Compra', stop=long_sl_price, limit=actual_limit_price, comment_profit='TP', comment_loss='SL/BE/TSL')

    // Add alert for SL/TP/BE/TSL exit
    if enable_webhook_alerts and webhook_url != ""
        string exit_alert_message = '{ "symbol": "' + syminfo.tickerid + '", "side": "sell", "qty": ' + str.tostring(strategy.position_size) + ', "type": "market", "reason": "SL/TP/BE/TSL" }'
        alert(exit_alert_message, alert.freq_once_per_bar_close, webhook=webhook_url)

// Salida 2: Inmediata por Condición "Peak Exit" vía strategy.close
if strategy.position_size > 0 and exit_peak_condition and not long_trl_active and isBullish
    strategy.close(id='Compra', comment='Peak Exit')

    // Add alert for Peak Exit
    if enable_webhook_alerts and webhook_url != ""
        string peak_exit_alert_message = '{ "symbol": "' + syminfo.tickerid + '", "side": "sell", "qty": ' + str.tostring(strategy.position_size) + ', "type": "market", "reason": "Peak Exit" }'
        alert(peak_exit_alert_message, alert.freq_once_per_bar_close, webhook=webhook_url)

if strategy.position_size > 0 and not isBullish
    strategy.close(id='Compra', comment='Trend Exit (HTF)')
    if enableWebhookAlerts and webhookUrl != ""
        string trendExitMsg = '{ "symbol": "' + syminfo.tickerid + '", "side": "sell", "qty": ' + str.tostring(strategy.position_size) + ', "type": "market", "reason": "Trend Exit HTF" }'
        alert(trendExitMsg + "{{webhook=" + webhookUrl + "}}", alert.freq_once_per_bar_close)

// *** VISUALIZACIÓN ***
// EMAs
plot(currentEma, "EMA Corta", color.new(color.yellow, 0), 1)
plot(htfEma, "EMA HTF", color.new(color.aqua, 0), 1)

// Stop Loss
plot(strategy.position_size > 0 ? stopLossPrice : na, "Stop Loss", color.new(color.red, 0), 2, plot.style_cross)
// Take Profit
plot(strategy.position_size > 0 and not trailingActive ? takeProfitPrice : na, "Take Profit", color.new(color.green, 0), 2, plot.style_cross)

// Plots de Depuración (activar/desactivar según necesidad)
plot_entryTrigger = input.bool(false, "Plot  entryTrigger", group="Debug Plots")
plotshape(plot_entryTrigger and entryTrigger, title="Execute Buy", style=shape.triangleup, location=location.bottom, color=color.new(color.green, 0), size=size.auto)

plot_canTrade = input.bool(false, "Plot canTrade", group="Debug Plots")
// plotshape(plot_canTrade and canTrade, title="Can Trade", style=shape.triangledown, location=location.top, color=color.new(color.blue, 0), size=size.small) // canTrade variable removed

plot_lrFilter = input.bool(false, "Plot lrFilter", group="Debug Plots")
bgcolor(plot_lrFilter and useLrTrendFilter ? color.new(color.purple, 90) : na, title="LR Filter")

plot_adxfilter = input.bool(false, "Plot adxfilter", group="Debug Plots")
bgcolor(plot_adxfilter and useAdxFilter ? color.new(color.orange, 90) : na, title="ADX Filter")

plot_volfilter = input.bool(false, "Plot volfilter", group="Debug Plots")
bgcolor(plot_volfilter and useVolFilter ? color.new(color.teal, 90) : na, title="Vol Filter")

plot_bullish = input.bool(false, "Plot bullish", group="Debug Plots")
// bgcolor(plot_bullish and bullish ? color.new(color.lime, 90) : na, title="Bullish Filter") // bullish variable removed